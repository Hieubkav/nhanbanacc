
      setForm(copy);
    }).catch(() => {}).finally(() => { if (mounted) setLoading(false); });
    return () => { mounted = false; };
  }, [convex, isEdit, id, resource]);

  const create = useMutation(mod.create);
  const update = useMutation(mod.update);

  // Set default values when creating new
  useEffect(() => {
    if (isEdit) return;
    setForm((s) => {
      const next: any = { ...s };
      if (fields.some((f) => f.name === "sortOrder") && (next.sortOrder === undefined || next.sortOrder === null || next.sortOrder === "")) {
        next.sortOrder = 1;
      }
      return next;
    });
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const onSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      // Chỉ pick các field được khai báo trong cấu hình để tránh gửi thừa (vd: createdAt, updatedAt)
      const dto: Record<string, any> = {};
      for (const f of fields) {
        const v = (form as any)[f.name];
        if (v !== undefined) dto[f.name] = v;
      }
      // Auto-generate slug nếu có field slug và đang trống
      if (fields.some((f) => f.name === "slug")) {
        const hasSlug = typeof dto.slug === "string" && String(dto.slug).trim() !== "";
        const baseName = (dto as any).name ?? (form as any).name ?? (dto as any).title ?? (form as any).title;
        if (!hasSlug && baseName) dto.slug = slugify(Strin
